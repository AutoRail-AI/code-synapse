/**
 * SmartSummary - Phase 5 Insight View
 *
 * Streaming typewriter effect for the LLM answer, interactive citations
 * that scroll to code cards, and model source footnote.
 *
 * @module
 */

import { useEffect, useState, useCallback } from "react";

export interface CitationRef {
  index: number;
  filePath: string;
  lineNumber?: number;
  snippet?: string;
  justification?: string;
}

interface SmartSummaryProps {
  /** LLM-generated answer text. */
  answer: string;
  /** Citations referenced in the answer as [1], [2], etc. */
  citations: CitationRef[];
  /** Model used for generation (e.g. "qwen2.5-coder-3b"). */
  modelUsed: string;
  /** Whether to use typewriter effect (default true). */
  typewriter?: boolean;
  /** Chars revealed per tick when typewriter enabled. */
  charsPerTick?: number;
  /** Tick interval in ms. */
  tickMs?: number;
  /** ID prefix for citation scroll targets (to disambiguate across chat turns). */
  resultIdPrefix?: string;
}

export function SmartSummary({
  answer,
  citations,
  modelUsed,
  typewriter = true,
  charsPerTick = 2,
  tickMs = 30,
  resultIdPrefix,
}: SmartSummaryProps) {
  const [displayedText, setDisplayedText] = useState("");
  const [isComplete, setIsComplete] = useState(false);

  const scrollToCitation = useCallback((index: number) => {
    const prefix = resultIdPrefix ? `${resultIdPrefix}-` : "";
    const el = document.getElementById(`search-result-${prefix}${index}`);
    el?.scrollIntoView({ behavior: "smooth", block: "center" });
  }, [resultIdPrefix]);

  // Typewriter effect
  useEffect(() => {
    if (!typewriter || !answer) {
      setDisplayedText(answer);
      setIsComplete(true);
      return;
    }
    setDisplayedText("");
    setIsComplete(false);
    let idx = 0;
    const interval = setInterval(() => {
      idx += charsPerTick;
      if (idx >= answer.length) {
        setDisplayedText(answer);
        setIsComplete(true);
        clearInterval(interval);
        return;
      }
      setDisplayedText(answer.slice(0, idx));
    }, tickMs);
    return () => clearInterval(interval);
  }, [answer, typewriter, charsPerTick, tickMs]);

  // Parse displayed text and render citation links [1], [2], etc.
  const renderWithCitations = () => {
    const regex = /\[(\d+)\]/g;
    const parts: React.ReactNode[] = [];
    let lastIndex = 0;
    let match: RegExpExecArray | null;
    while ((match = regex.exec(displayedText)) !== null) {
      const before = displayedText.slice(lastIndex, match.index);
      const num = parseInt(match[1], 10);
      const isKnown = num >= 1 && num <= citations.length;
      parts.push(<span key={`t-${lastIndex}`}>{before}</span>);
      parts.push(
        <button
          key={`c-${match.index}`}
          type="button"
          onClick={() => scrollToCitation(num - 1)}
          className={`inline-flex items-center justify-center min-w-[1.25rem] h-5 px-1 rounded text-xs font-mono transition-colors ${
            isKnown
              ? "text-blue-400 hover:text-blue-300 hover:bg-blue-500/20 border border-blue-500/40 cursor-pointer"
              : "text-slate-500 cursor-default"
          }`}
          title={isKnown ? `Scroll to citation ${num}` : undefined}
        >
          [{num}]
        </button>
      );
      lastIndex = regex.lastIndex;
    }
    parts.push(
      <span key={`t-${lastIndex}`}>{displayedText.slice(lastIndex)}</span>
    );
    return parts;
  };

  return (
    <div className="space-y-3">
      <div className="text-sm text-slate-200 leading-relaxed whitespace-pre-wrap">
        {renderWithCitations()}
        {!isComplete && answer && (
          <span className="inline-block w-2 h-4 ml-0.5 bg-blue-400 animate-pulse" />
        )}
      </div>
      <footer className="text-xs text-slate-500 border-t border-slate-700 pt-2">
        Generated by {modelUsed || "local model"}
      </footer>
    </div>
  );
}
