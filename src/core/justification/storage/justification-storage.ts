/**
 * Justification Storage Module
 *
 * CozoDB operations for storing and retrieving business justifications.
 * Handles atomic writes, queries, and relationship management.
 *
 * Note: All table and column names use snake_case to match CozoDB schema
 * generated by schema-generator.ts (which converts PascalCase to snake_case).
 *
 * @module
 */

import type { IGraphStore } from "../../interfaces/IGraphStore.js";
import type {
  EntityJustification,
  ClarificationQuestion,
  JustificationStats,
  ConfidenceLevel,
} from "../models/justification.js";

// =============================================================================
// Types
// =============================================================================

/**
 * Row format for justification table in CozoDB (snake_case)
 */
export interface JustificationRow {
  id: string;
  entity_id: string;
  entity_type: string;
  name: string;
  file_path: string;
  purpose_summary: string;
  business_value: string;
  feature_context: string;
  detailed_description: string | null;
  tags: string; // JSON string array
  inferred_from: string;
  confidence_score: number;
  confidence_level: string;
  reasoning: string | null;
  evidence_sources: string; // JSON string array
  parent_justification_id: string | null;
  hierarchy_depth: number;
  clarification_pending: boolean;
  pending_questions: string; // JSON string array of ClarificationQuestion
  last_confirmed_by_user: number | null;
  confirmed_by_user_id: string | null;
  created_at: number;
  updated_at: number;
  version: number;
}

/**
 * Row format for clarification_question table (snake_case)
 */
export interface ClarificationQuestionRow {
  id: string;
  justification_id: string;
  entity_id: string;
  question: string;
  context: string | null;
  priority: number;
  category: string;
  suggested_answers: string; // JSON string array
  answered: boolean;
  answer: string | null;
  answered_at: number | null;
  created_at: number;
}

/**
 * Row format for project_context table (snake_case)
 */
export interface ProjectContextRow {
  id: string;
  project_name: string;
  project_description: string | null;
  domain: string | null;
  framework: string | null;
  known_features: string; // JSON string array
  business_goals: string; // JSON string array
  updated_at: number;
}

// =============================================================================
// Justification Storage Class
// =============================================================================

/**
 * Handles all CozoDB operations for the justification layer.
 */
export class JustificationStorage {
  constructor(private graphStore: IGraphStore) {}

  // ===========================================================================
  // Write Operations
  // ===========================================================================

  /**
   * Store a justification (insert or update)
   */
  async storeJustification(justification: EntityJustification): Promise<void> {
    const row = this.toRow(justification);

    const query = `
      ?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] <- [[
          $id, $entity_id, $entity_type, $name, $file_path, $purpose_summary, $business_value,
          $feature_context, $detailed_description, $tags, $inferred_from, $confidence_score,
          $confidence_level, $reasoning, $evidence_sources, $parent_justification_id,
          $hierarchy_depth, $clarification_pending, $pending_questions, $last_confirmed_by_user,
          $confirmed_by_user_id, $created_at, $updated_at, $version
        ]]
      :put justification {
        id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version
      }
    `;

    await this.graphStore.execute(query, row as unknown as Record<string, unknown>);

    // Create has_justification relationship
    await this.createJustificationRelationship(justification.entityId, justification.id);
  }

  /**
   * Store multiple justifications in a batch with atomic writes
   *
   * ATOMIC GUARANTEES:
   * - All justifications stored or none (transactional)
   * - has_justification edges created for each
   * - JUSTIFICATION_HIERARCHY edges created for parent-child relationships
   * - No orphan justifications (edge creation is part of atomic unit)
   */
  async storeJustifications(justifications: EntityJustification[]): Promise<void> {
    if (justifications.length === 0) return;

    // Build a map of entity IDs to justifications for hierarchy lookup
    const justificationMap = new Map<string, EntityJustification>();
    for (const j of justifications) {
      justificationMap.set(j.entityId, j);
    }

    await this.graphStore.transaction(async (tx) => {
      for (const justification of justifications) {
        const row = this.toRow(justification);

        // 1. Store the justification node
        const query = `
          ?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
            feature_context, detailed_description, tags, inferred_from, confidence_score,
            confidence_level, reasoning, evidence_sources, parent_justification_id,
            hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
            confirmed_by_user_id, created_at, updated_at, version] <- [[
              $id, $entity_id, $entity_type, $name, $file_path, $purpose_summary, $business_value,
              $feature_context, $detailed_description, $tags, $inferred_from, $confidence_score,
              $confidence_level, $reasoning, $evidence_sources, $parent_justification_id,
              $hierarchy_depth, $clarification_pending, $pending_questions, $last_confirmed_by_user,
              $confirmed_by_user_id, $created_at, $updated_at, $version
            ]]
          :put justification {
            id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
            feature_context, detailed_description, tags, inferred_from, confidence_score,
            confidence_level, reasoning, evidence_sources, parent_justification_id,
            hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
            confirmed_by_user_id, created_at, updated_at, version
          }
        `;

        await tx.execute(query, row as unknown as Record<string, unknown>);
      }
    });

    // Create entity relationships and hierarchy edges (outside main transaction for perf)
    for (const justification of justifications) {
      // Create has_justification edge to entity
      await this.createJustificationRelationship(justification.entityId, justification.id);

      // Create JUSTIFICATION_HIERARCHY edge if parent exists
      if (justification.parentJustificationId) {
        await this.createHierarchyEdge(
          justification.parentJustificationId,
          justification.id,
          "parent_of"
        );
      }
    }
  }

  /**
   * Create JUSTIFICATION_HIERARCHY edge between parent and child justifications
   */
  private async createHierarchyEdge(
    parentJustificationId: string,
    childJustificationId: string,
    relationshipType: "parent_of" | "child_of"
  ): Promise<void> {
    try {
      const query = `
        ?[from_id, to_id, relationship_type] <- [[$parentId, $childId, $relationshipType]]
        :put justification_hierarchy { from_id, to_id, relationship_type }
      `;
      await this.graphStore.execute(query, {
        parentId: parentJustificationId,
        childId: childJustificationId,
        relationshipType,
      });
    } catch (_error) {
      // Log but don't fail - hierarchy edges are supplementary
      // The core justification is already stored
    }
  }

  /**
   * Create has_justification relationship
   */
  private async createJustificationRelationship(
    entityId: string,
    justificationId: string
  ): Promise<void> {
    // Try each entity type - CozoDB will only succeed for the correct type
    const entityTypes = ["file", "function", "class", "interface", "type_alias", "variable", "module"];

    for (const _entityType of entityTypes) {
      try {
        const query = `
          ?[from_id, to_id] <- [[$entityId, $justificationId]]
          :put has_justification { from_id, to_id }
        `;
        await this.graphStore.execute(query, { entityId, justificationId });
        return; // Success - entity exists in this table
      } catch {
        // Entity not in this table, try next
      }
    }
  }

  /**
   * Store a clarification question
   */
  async storeClarificationQuestion(question: ClarificationQuestion): Promise<void> {
    const query = `
      ?[id, justification_id, entity_id, question, context, priority, category,
        suggested_answers, answered, answer, answered_at, created_at] <- [[
          $id, $justification_id, $entity_id, $question, $context, $priority, $category,
          $suggested_answers, $answered, $answer, $answered_at, $created_at
        ]]
      :put clarification_question {
        id, justification_id, entity_id, question, context, priority, category,
        suggested_answers, answered, answer, answered_at, created_at
      }
    `;

    await this.graphStore.execute(query, {
      id: question.id,
      justification_id: question.entityId, // Will be linked to justification
      entity_id: question.entityId,
      question: question.question,
      context: question.context || null,
      priority: question.priority,
      category: question.category,
      suggested_answers: JSON.stringify(question.suggestedAnswers || []),
      answered: question.answered,
      answer: question.answer || null,
      answered_at: question.answeredAt || null,
      created_at: Date.now(),
    });
  }

  /**
   * Update project context
   */
  async updateProjectContext(context: {
    projectName: string;
    projectDescription?: string;
    domain?: string;
    framework?: string;
    knownFeatures?: string[];
    businessGoals?: string[];
  }): Promise<void> {
    const query = `
      ?[id, project_name, project_description, domain, framework, known_features,
        business_goals, updated_at] <- [[
          "project-context", $project_name, $project_description, $domain, $framework,
          $known_features, $business_goals, $updated_at
        ]]
      :put project_context {
        id, project_name, project_description, domain, framework, known_features,
        business_goals, updated_at
      }
    `;

    await this.graphStore.execute(query, {
      project_name: context.projectName,
      project_description: context.projectDescription || null,
      domain: context.domain || null,
      framework: context.framework || null,
      known_features: JSON.stringify(context.knownFeatures || []),
      business_goals: JSON.stringify(context.businessGoals || []),
      updated_at: Date.now(),
    });
  }

  // ===========================================================================
  // Read Operations
  // ===========================================================================

  /**
   * Get justification by entity ID
   */
  async getByEntityId(entityId: string): Promise<EntityJustification | null> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        entity_id = $entityId`,
      { entityId }
    );

    const row = result.rows[0];
    if (!row) return null;
    return this.fromRow(row);
  }

  /**
   * Get justification by justification ID
   */
  async getById(id: string): Promise<EntityJustification | null> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        id = $id`,
      { id }
    );

    const row = result.rows[0];
    if (!row) return null;
    return this.fromRow(row);
  }

  /**
   * Get multiple justifications by entity IDs
   */
  async getByEntityIds(entityIds: string[]): Promise<Map<string, EntityJustification>> {
    const result = new Map<string, EntityJustification>();
    if (entityIds.length === 0) return result;

    // Query in batches of 100
    const batchSize = 100;
    for (let i = 0; i < entityIds.length; i += batchSize) {
      const batch = entityIds.slice(i, i + batchSize);
      const idList = batch.map((id) => `"${id}"`).join(", ");

      const queryResult = await this.graphStore.query<JustificationRow>(
        `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version] :=
          *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
            feature_context, detailed_description, tags, inferred_from, confidence_score,
            confidence_level, reasoning, evidence_sources, parent_justification_id,
            hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
            confirmed_by_user_id, created_at, updated_at, version},
          entity_id in [${idList}]`
      );

      for (const row of queryResult.rows) {
        result.set(row.entity_id, this.fromRow(row));
      }
    }

    return result;
  }

  /**
   * Get all justifications for a file
   */
  async getByFilePath(filePath: string): Promise<EntityJustification[]> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        file_path = $filePath`,
      { filePath }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  /**
   * Get pending clarification questions (sorted by priority)
   */
  async getPendingClarifications(limit: number = 100): Promise<ClarificationQuestion[]> {
    const result = await this.graphStore.query<ClarificationQuestionRow>(
      `?[id, justification_id, entity_id, question, context, priority, category,
        suggested_answers, answered, answer, answered_at, created_at] :=
        *clarification_question{id, justification_id, entity_id, question, context, priority,
          category, suggested_answers, answered, answer, answered_at, created_at},
        answered = false
      :order priority
      :limit $limit`,
      { limit }
    );

    return result.rows.map((row) => this.questionFromRow(row));
  }

  /**
   * Get entities needing clarification (low confidence or pending)
   */
  async getEntitiesNeedingClarification(): Promise<EntityJustification[]> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        or(clarification_pending = true, confidence_score < 0.5)
      :order hierarchy_depth, -confidence_score`
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  /**
   * Get justification statistics
   */
  async getStats(): Promise<JustificationStats> {
    // Total entities with justifications
    const totalResult = await this.graphStore.query<{ count: number }>(
      `?[count(id)] := *justification{id}`
    );

    // By confidence level - CozoDB returns column names with aggregation syntax
    type CountRow = Record<string, number>;

    const highResult = await this.graphStore.query<CountRow>(
      `?[count(id)] := *justification{id, confidence_score}, confidence_score >= 0.8`
    );

    const mediumResult = await this.graphStore.query<CountRow>(
      `?[count(id)] := *justification{id, confidence_score}, confidence_score >= 0.5, confidence_score < 0.8`
    );

    const lowResult = await this.graphStore.query<CountRow>(
      `?[count(id)] := *justification{id, confidence_score}, confidence_score >= 0.3, confidence_score < 0.5`
    );

    const pendingResult = await this.graphStore.query<CountRow>(
      `?[count(id)] := *justification{id, clarification_pending}, clarification_pending = true`
    );

    const confirmedResult = await this.graphStore.query<CountRow>(
      `?[count(id)] := *justification{id, last_confirmed_by_user}, last_confirmed_by_user != null`
    );

    // Total justifiable entities (approximate) - query each type separately
    const functionsCount = await this.graphStore.query<CountRow>(
      `?[count(id)] := *function{id}`
    );
    const classesCount = await this.graphStore.query<CountRow>(
      `?[count(id)] := *class{id}`
    );
    const interfacesCount = await this.graphStore.query<CountRow>(
      `?[count(id)] := *interface{id}`
    );
    const filesCount = await this.graphStore.query<CountRow>(
      `?[count(id)] := *file{id}`
    );

    // Helper to extract first numeric value from row
    const getCount = (row?: CountRow): number => {
      if (!row) return 0;
      const values = Object.values(row);
      return typeof values[0] === "number" ? values[0] : 0;
    };

    const totalJustifications = getCount(totalResult.rows[0]);
    const totalEntities =
      getCount(functionsCount.rows[0]) +
      getCount(classesCount.rows[0]) +
      getCount(interfacesCount.rows[0]) +
      getCount(filesCount.rows[0]);

    return {
      totalEntities: totalEntities,
      justifiedEntities: totalJustifications,
      highConfidence: getCount(highResult.rows[0]),
      mediumConfidence: getCount(mediumResult.rows[0]),
      lowConfidence: getCount(lowResult.rows[0]),
      pendingClarification: getCount(pendingResult.rows[0]),
      userConfirmed: getCount(confirmedResult.rows[0]),
      coveragePercentage:
        totalEntities > 0 ? (totalJustifications / totalEntities) * 100 : 0,
    };
  }

  /**
   * Search justifications by text
   */
  async searchByText(query: string, limit: number = 50): Promise<EntityJustification[]> {
    // Use full-text search on purpose_summary and business_value
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        or(
          str_includes(purpose_summary, $query),
          str_includes(business_value, $query),
          str_includes(feature_context, $query)
        )
      :limit $limit`,
      { query, limit }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  // ===========================================================================
  // Hierarchical Traversal Queries (Agent-First)
  // ===========================================================================

  /**
   * Get child justifications for a parent justification
   * Traverses the JUSTIFICATION_HIERARCHY edge
   */
  async getChildren(parentJustificationId: string): Promise<EntityJustification[]> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        parent_justification_id = $parentId
      :order hierarchy_depth`,
      { parentId: parentJustificationId }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  /**
   * Get ancestors (parent chain) for a justification
   * Traverses up the hierarchy to the root
   */
  async getAncestors(justificationId: string): Promise<EntityJustification[]> {
    const ancestors: EntityJustification[] = [];
    let currentId: string | null = justificationId;

    // Traverse up the tree (max 10 levels to prevent infinite loops)
    for (let depth = 0; depth < 10 && currentId; depth++) {
      const current = await this.getById(currentId);
      if (!current) break;

      if (current.parentJustificationId) {
        const parent = await this.getById(current.parentJustificationId);
        if (parent) {
          ancestors.push(parent);
          currentId = parent.id;
        } else {
          currentId = null;
        }
      } else {
        currentId = null;
      }
    }

    return ancestors;
  }

  /**
   * Get complete file hierarchy with justifications
   * Returns justifications ordered by hierarchy depth (file -> classes -> methods)
   */
  async getFileHierarchyJustifications(filePath: string): Promise<{
    file: EntityJustification | null;
    topLevel: EntityJustification[];
    nested: Map<string, EntityJustification[]>;
  }> {
    const justifications = await this.getByFilePath(filePath);

    // Find file-level justification
    const file = justifications.find((j) => j.entityType === "file") || null;

    // Find top-level entities (classes, functions at file level)
    const topLevel = justifications.filter(
      (j) =>
        j.entityType !== "file" &&
        (j.hierarchyDepth === 1 || !j.parentJustificationId)
    );

    // Group nested entities by parent
    const nested = new Map<string, EntityJustification[]>();
    for (const j of justifications) {
      if (j.parentJustificationId && j.hierarchyDepth > 1) {
        const existing = nested.get(j.parentJustificationId) || [];
        existing.push(j);
        nested.set(j.parentJustificationId, existing);
      }
    }

    return { file, topLevel, nested };
  }

  /**
   * Get justifications by feature context
   */
  async getByFeature(
    featureContext: string,
    limit: number = 100
  ): Promise<EntityJustification[]> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        feature_context = $featureContext
      :order -confidence_score
      :limit $limit`,
      { featureContext, limit }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  /**
   * Get justifications within a confidence range
   */
  async getByConfidenceRange(
    minConfidence: number,
    maxConfidence: number,
    limit: number = 100
  ): Promise<EntityJustification[]> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        confidence_score >= $minConfidence,
        confidence_score <= $maxConfidence
      :order confidence_score
      :limit $limit`,
      { minConfidence, maxConfidence, limit }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  // ===========================================================================
  // Uncertainty Hotspot Queries
  // ===========================================================================

  /**
   * Get files ranked by uncertainty (most low-confidence justifications)
   * Used to identify areas needing attention
   */
  async getUncertaintyHotspots(limit: number = 20): Promise<
    Array<{
      filePath: string;
      lowConfidenceCount: number;
      pendingClarificationCount: number;
      averageConfidence: number;
      totalEntities: number;
    }>
  > {
    // Get all low-confidence and pending justifications grouped by file
    type HotspotRow = {
      file_path: string;
      low_confidence_count: number;
      pending_count: number;
      total_count: number;
      avg_confidence: number;
    };

    const result = await this.graphStore.query<HotspotRow>(
      `?[file_path, low_confidence_count, pending_count, total_count, avg_confidence] :=
        *justification{file_path, confidence_score, clarification_pending},
        total_count = count(file_path),
        low_confidence_count = count_if(confidence_score < 0.5),
        pending_count = count_if(clarification_pending = true),
        avg_confidence = mean(confidence_score)
      :order -low_confidence_count, -pending_count
      :limit $limit`,
      { limit }
    );

    return result.rows.map((row) => ({
      filePath: row.file_path,
      lowConfidenceCount: row.low_confidence_count,
      pendingClarificationCount: row.pending_count,
      averageConfidence: row.avg_confidence,
      totalEntities: row.total_count,
    }));
  }

  /**
   * Get entities with lowest confidence (most uncertain)
   */
  async getLowestConfidenceEntities(limit: number = 50): Promise<EntityJustification[]> {
    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version}
      :order confidence_score
      :limit $limit`,
      { limit }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  /**
   * Get features with lowest average confidence
   * Used to identify which features need more attention
   */
  async getUncertainFeatures(limit: number = 10): Promise<
    Array<{
      featureContext: string;
      averageConfidence: number;
      entityCount: number;
      lowConfidenceCount: number;
    }>
  > {
    type FeatureRow = {
      feature_context: string;
      avg_confidence: number;
      entity_count: number;
      low_count: number;
    };

    const result = await this.graphStore.query<FeatureRow>(
      `?[feature_context, avg_confidence, entity_count, low_count] :=
        *justification{feature_context, confidence_score},
        feature_context != "",
        feature_context != "General",
        avg_confidence = mean(confidence_score),
        entity_count = count(feature_context),
        low_count = count_if(confidence_score < 0.5)
      :order avg_confidence
      :limit $limit`,
      { limit }
    );

    return result.rows.map((row) => ({
      featureContext: row.feature_context,
      averageConfidence: row.avg_confidence,
      entityCount: row.entity_count,
      lowConfidenceCount: row.low_count,
    }));
  }

  /**
   * Get justifications that were recently updated but still uncertain
   * (May indicate difficult-to-understand code)
   */
  async getRecentlyUpdatedUncertain(
    sinceDaysAgo: number = 7,
    limit: number = 50
  ): Promise<EntityJustification[]> {
    const sinceTimestamp = Date.now() - sinceDaysAgo * 24 * 60 * 60 * 1000;

    const result = await this.graphStore.query<JustificationRow>(
      `?[id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
        feature_context, detailed_description, tags, inferred_from, confidence_score,
        confidence_level, reasoning, evidence_sources, parent_justification_id,
        hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
        confirmed_by_user_id, created_at, updated_at, version] :=
        *justification{id, entity_id, entity_type, name, file_path, purpose_summary, business_value,
          feature_context, detailed_description, tags, inferred_from, confidence_score,
          confidence_level, reasoning, evidence_sources, parent_justification_id,
          hierarchy_depth, clarification_pending, pending_questions, last_confirmed_by_user,
          confirmed_by_user_id, created_at, updated_at, version},
        updated_at >= $sinceTimestamp,
        confidence_score < 0.5
      :order -updated_at
      :limit $limit`,
      { sinceTimestamp, limit }
    );

    return result.rows.map((row) => this.fromRow(row));
  }

  // ===========================================================================
  // Delete Operations
  // ===========================================================================

  /**
   * Delete justification by entity ID
   */
  async deleteByEntityId(entityId: string): Promise<void> {
    // First get the justification ID
    const justification = await this.getByEntityId(entityId);
    if (!justification) return;

    // Delete associated clarification questions
    await this.graphStore.execute(
      `?[id] := *clarification_question{id, entity_id}, entity_id = $entityId
       :rm clarification_question { id }`,
      { entityId }
    );

    // Delete the justification
    await this.graphStore.execute(
      `?[id] := *justification{id, entity_id}, entity_id = $entityId
       :rm justification { id }`,
      { entityId }
    );
  }

  /**
   * Delete all justifications for a file
   */
  async deleteByFilePath(filePath: string): Promise<void> {
    // Get all entity IDs in this file
    const justifications = await this.getByFilePath(filePath);

    for (const j of justifications) {
      await this.deleteByEntityId(j.entityId);
    }
  }

  /**
   * Clear all justifications
   */
  async clearAll(): Promise<void> {
    await this.graphStore.execute(`?[id] := *clarification_question{id} :rm clarification_question { id }`);
    await this.graphStore.execute(`?[id] := *justification{id} :rm justification { id }`);
    await this.graphStore.execute(`?[id] := *project_context{id} :rm project_context { id }`);
  }

  /**
   * Mark clarification question as answered
   */
  async answerClarificationQuestion(questionId: string, answer: string): Promise<void> {
    await this.graphStore.execute(
      `?[id, answered, answer, answered_at] <- [[$id, true, $answer, $answered_at]]
       :update clarification_question { id => answered, answer, answered_at }`,
      { id: questionId, answer, answered_at: Date.now() }
    );
  }

  // ===========================================================================
  // Row Conversion
  // ===========================================================================

  /**
   * Convert EntityJustification to database row (snake_case)
   */
  private toRow(j: EntityJustification): JustificationRow {
    return {
      id: j.id,
      entity_id: j.entityId,
      entity_type: j.entityType,
      name: j.name,
      file_path: j.filePath,
      purpose_summary: j.purposeSummary,
      business_value: j.businessValue,
      feature_context: j.featureContext,
      detailed_description: j.detailedDescription || null,
      tags: JSON.stringify(j.tags),
      inferred_from: j.inferredFrom,
      confidence_score: j.confidenceScore,
      confidence_level: j.confidenceLevel,
      reasoning: j.reasoning || null,
      evidence_sources: JSON.stringify(j.evidenceSources),
      parent_justification_id: j.parentJustificationId,
      hierarchy_depth: j.hierarchyDepth,
      clarification_pending: j.clarificationPending,
      pending_questions: JSON.stringify(j.pendingQuestions),
      last_confirmed_by_user: j.lastConfirmedByUser,
      confirmed_by_user_id: j.confirmedByUserId,
      created_at: j.createdAt,
      updated_at: j.updatedAt,
      version: j.version,
    };
  }

  /**
   * Convert database row (snake_case) to EntityJustification
   */
  private fromRow(row: JustificationRow): EntityJustification {
    return {
      id: row.id,
      entityId: row.entity_id,
      entityType: row.entity_type as EntityJustification["entityType"],
      name: row.name,
      filePath: row.file_path,
      purposeSummary: row.purpose_summary,
      businessValue: row.business_value,
      featureContext: row.feature_context,
      detailedDescription: row.detailed_description || "",
      tags: this.parseJsonArray(row.tags),
      inferredFrom: row.inferred_from as EntityJustification["inferredFrom"],
      confidenceScore: row.confidence_score,
      confidenceLevel: row.confidence_level as ConfidenceLevel,
      reasoning: row.reasoning || "",
      evidenceSources: this.parseJsonArray(row.evidence_sources),
      parentJustificationId: row.parent_justification_id,
      hierarchyDepth: row.hierarchy_depth,
      clarificationPending: row.clarification_pending,
      pendingQuestions: this.parseJsonArray(row.pending_questions),
      lastConfirmedByUser: row.last_confirmed_by_user,
      confirmedByUserId: row.confirmed_by_user_id,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      version: row.version,
    };
  }

  /**
   * Convert database row (snake_case) to ClarificationQuestion
   */
  private questionFromRow(row: ClarificationQuestionRow): ClarificationQuestion {
    return {
      id: row.id,
      entityId: row.entity_id,
      question: row.question,
      context: row.context || "",
      priority: row.priority,
      category: row.category as ClarificationQuestion["category"],
      suggestedAnswers: this.parseJsonArray(row.suggested_answers),
      answered: row.answered,
      answer: row.answer || undefined,
      answeredAt: row.answered_at || undefined,
    };
  }

  /**
   * Safely parse JSON array from string
   */
  private parseJsonArray<T>(json: string): T[] {
    try {
      const parsed = JSON.parse(json);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }
}

// =============================================================================
// Factory
// =============================================================================

/**
 * Create a justification storage instance
 */
export function createJustificationStorage(graphStore: IGraphStore): JustificationStorage {
  return new JustificationStorage(graphStore);
}
